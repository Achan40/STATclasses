sd(ACC_all_folds)
# set seed
set.seed(14572)
# load data
data(Glass, package = "mlbench")
# coerce to tibble
glass = as_tibble(Glass)
# store indexes for 10 fold cross-validation
index_fold = caret::createFolds(glass$Type, k = 5)
#Create Accuracy funciton
calc_ACC = function(actual,predicted){
mean(actual==predicted)
}
#Accuracy functino for one fold
calc_ACC_fold = function(fold_idx){
est = glass[-fold_idx, ]
val = glass[fold_idx, ]
pred_val = predict(rpart(Type~., data = est, cp =.01,minsplit = 20),val,type = "class") #create model and predict with val data
calc_ACC(actual = val$Type,predicted = pred_val)
}
#ACC all folds
ACC_all_folds = map_dbl(index_fold,calc_ACC_fold)
#cross validation ACC&se
mean(ACC_all_folds)
sd(ACC_all_folds)
# set seed
set.seed(14572)
# load data
data(Glass, package = "mlbench")
# coerce to tibble
glass = as_tibble(Glass)
# store indexes for 10 fold cross-validation
index_fold = caret::createFolds(glass$Type, k = 5)
#Create Accuracy funciton
calc_ACC = function(actual,predicted){
mean(actual==predicted)
}
#Accuracy functino for one fold
calc_ACC_fold = function(fold_idx){
est = glass[-fold_idx, ]
val = glass[fold_idx, ]
pred_val = predict(rpart(Type~., data = est, cp =.01,minsplit = 20),val,type = "class") #create model and predict with val data
calc_ACC(actual = val$Type,predicted = pred_val)
}
#ACC all folds
ACC_all_folds = map_dbl(index_fold,calc_ACC_fold)
#cross validation ACC&se
mean(ACC_all_folds)
sd(ACC_all_folds)
#8.7
# load packages
library("purrr")
library("tibble")
library("rpart")
# set seed
set.seed(50200)
# load data
data(Glass, package = "mlbench")
# coerce to tibble
glass = as_tibble(Glass)
# store indexes for 10 fold cross-validation
index_fold = caret::createFolds(glass$Type, k = 5)
#Create Accuracy funciton
calc_ACC = function(actual,predicted){
mean(actual==predicted)
}
#Accuracy functino for one fold
calc_ACC_fold = function(fold_idx){
est = glass[-fold_idx, ]
val = glass[fold_idx, ]
pred_val = predict(rpart(Type~., data = est, cp =.001,minsplit = 20),val,type = "class") #create model and predict with val data
calc_ACC(actual = val$Type,predicted = pred_val)
}
#ACC all folds
ACC_all_folds = map_dbl(index_fold,calc_ACC_fold)
#cross validation ACC&se
mean(ACC_all_folds)
sd(ACC_all_folds)
#8.9
# load packages
library("purrr")
library("tibble")
# set seed
set.seed(91113)
# load and coerce data to tibble
bstn = as_tibble(MASS::Boston)
# store indexes for 10 fold cross-validation
index_fold = caret::createFolds(bstn$medv, k = 10)
#function for the metric
calc_metric = function(actual,predicted){
sum(abs(actual-predicted)>3)/length(actual)
}
#metric for a specific fold
calc_metric_fold = function(fold_idx){
est = bstn[-fold_idx, ]
val = bstn[fold_idx, ]
pred_val = predict(lm(medv~black, data = est),val)
calc_metric(actual = val$medv,predicted = pred_val)
}
#numeric so map_dbl
metric_all_folds = map_dbl(index_fold, calc_metric_fold)
#10fold cross validate is mean of all those metric of folds
mean(metric_all_folds)
sd(metric_all_folds)
#1
data(salmonella)
library(faraway)
#1
data(salmonella)
mod1 = lm(colonies ~ log(dose +1), data = salmonella)
summary(mod1)
View(salmonella)
#lack of fit (sigma^2 unknown)
plot(mod1)
#lack of fit (sigma^2 unknown)
plot(lm(colonies ~ log(does + 1), data = salmonella)
#lack of fit (sigma^2 unknown)
>
3
><
\
#lack of fit (sigma^2 unknown)
plot(lm(colonies ~ log(does + 1), data = salmonella)
#lack of fit (sigma^2 unknown)
plot(lm(colonies ~ log(does + 1), data = salmonella);abline(coef(mod1))
#lack of fit (sigma^2 unknown)
plot(lm(colonies ~ log(does + 1), data = salmonella)abline(coef(mod1))
#lack of fit (sigma^2 unknown)
plot(lm(colonies ~ log(does + 1), data = salmonella)
#lack of fit (sigma^2 unknown)
plot(lm(colonies ~ log(does + 1), data = salmonella))
abline(coef(mod1))
#lack of fit (sigma^2 unknown)
plot(lm(colonies ~ log(does + 1), data = salmonella))
#lack of fit (sigma^2 unknown)
plot(lm(colonies ~ log(dose + 1), data = salmonella))
salmonella[order(salmonella$dose)]
salmonella[order(salmonella$dose),]
View(salmonella)
library(faraway)
#1
data(salmonella)
salmonella[order(salmonella$dose),]
mod1 = lm(colonies ~ log(dose + 1), data = salmonella)
summary(mod1)
#lack of fit (sigma^2 unknown)
plot(lm(colonies ~ log(dose + 1), data = salmonella))
#lack of fit (sigma^2 unknown)
plot(lm(colonies ~ dose + 1, data = salmonella))
#lack of fit (sigma^2 unknown)
plot(lm(colonies ~ I(log(dose + 1)), data = salmonella))
#lack of fit (sigma^2 unknown)
plot(lm(colonies ~ I(log(dose + 1)), data = salmonella))
#lack of fit (sigma^2 unknown)
plot(lm(colonies ~ log(dose + 1), data = salmonella))
#lack of fit (sigma^2 unknown)
plot(colonies ~ log(dose + 1), data = salmonella)
#lack of fit (sigma^2 unknown)
plot(colonies ~ I(log(dose + 1)), data = salmonella)
#lack of fit (sigma^2 unknown)
plot(colonies ~ log(dose + 1), data = salmonella)
abline(coef(mod1))
mod1f = lm(colonies ~ factor(log(dose + 1)), data = salmonella)
cbind(salmonella,mod1f$fitted)[order(salmonella$dose)]
cbind(salmonella,mod1f$fitted)[order(salmonella$log(dose + 1)]
cbind(salmonella,mod1f$fitted)[order(salmonella$log(dose + 1))]
mod1f = lm(colonies ~ factor(dose), data = salmonella)
cbind(salmonella,mod1f$fitted)[order(salmonella$dose)]
cbind(salmonella,mod1f$fitted)[order(salmonella$dose),]
#Anova test
anova(mod1,mod1f)
#Anova test
lof_Anova = anova(mod1,mod1f)
lof_Anova
names(lof_Anova)
lof_Anova$F
lof_Anova$F[2]
lof_Anova[Df]
lof_Anova$Df
lof_Anova$Res.Df
1-pf(lof_Anovaq$F[2],lof_Anova$Res.Df[2],lof_Anova$Df[2])
#Anova test
lof_Anova = anova(mod1,mod1f)
1-pf(lof_Anova$F[2],lof_Anova$Res.Df[2],lof_Anova$Df[2])
lof_Anova$Res.Df
1-pf(lof_Anova$F[2],1-lof_Anova$Df[2],lof_Anova$Df[2])
lof_Anova
1-pf(lof_Anova$F[2],4,5)
1-pf(lof_Anova$F[2],4,12)
#Problem 2
data(gammaray)
head(gammaray)
mod1 = lm(colonies ~ log(I(dose + 1)), data = salmonella)
summary(mod1)
mod1 = lm(colonies ~ log(dose + 1), data = salmonella)
summary(mod1)
#Problem 2
data(gammaray)
head(gammaray)
mod2 = lm(flux ~ time, data = gammaray, weights = 1/error )
data("strongx")
head(strongx)
View(gammaray)
View(strongx)
summary(mod2u)
mod2u = lm(flux ~ time, data = gammaray)
summary(mod2u)
#Problem 2
data(gammaray)
mod2 = lm(flux ~ time, data = gammaray, weights = 1/error^2 )
summary(mod2)
summary(mod2)$sig
summary(mod2)$Df
names(summary(mod2))
summary(mod2)$df
#lack of fit test (sigma^2 known, it's given as the error column)
1-pchisq(summary(mod2)$sig^2*sumary(mod2)$df[2],sumary(mod2)$df[2])
#lack of fit test (sigma^2 known, it's given as the error column)
1-pchisq(summary(mod2)$sig^2*61,61
#lack of fit test (sigma^2 known, it's given as the error column)
1-pchisq(summary(mod2)$sig^2*61,61)
#lack of fit test (sigma^2 known, it's given as the error column)
1-pchisq(summary(mod2)$sig^2*61,61)
#weighted model
mod2 = lm(flux ~ time, data = gammaray, weights = 1/error^2 )
summary(mod2)
summary(mod2)$sig^2
#estimate sigma-sq
cbind(summary(mod2u)$sig^2, sum(gu$res^2)/61)
#estimate sigma-sq
cbind(summary(mod2u)$sig^2, sum(mod2u$res^2)/61)
#WLS, these two do not agree
summary(mod2)$sig^2
legend("topleft", col=c("red"), lty=c(1,2), legend=c("WLS"))
#Problem 2
data(gammaray)
#weighted model
mod2 = lm(flux ~ time, data = gammaray, weights = 1/error^2 )
summary(mod2)
plot(flux ~ time, data = gammaray, cex=sd);
plot(flux ~ time, data = gammaray, cex=error);
points(flux ~ time, data=gammaray, pch=2)
abline(mod2, col="red", lty=1, lwd=2);
legend("topleft", col=c("red"), lty=c(1,2), legend=c("WLS"))
#Trying with poly nomials
mod2sq = lm(flux ~ time + I(time^2), data = gammaray, weights = 1/error^2 )
anova(mod2,mod2sq)
group = data.frame(x=c(0,1,2), number of trials =c(1,1,1), Y = c(1,2,1))
#Problem 2
data(gammaray)
mod2 = lm(flux ~ time, data = gammaray, weights = 1/error^2 )
round(summary(mod2)$coef,dig = 3)
g2 = lm(flux ~ time + I(time^2), data = gammaray, weights = 1/error^2)
round(summary(g2)$coef,dig=3)
g3 = lm(flux ~ time + I(time^2) + I(time^3), data = gammaray , weights = 1/error^2)
round(summary(g3)$coef,dig=3) # Select d=2
summary(mod2)
mod2 = glm(flux ~ time, data = gammaray, weights = 1/error^2 )
summary(mod2)
mod2 = lm(flux ~ time, data = gammaray, weights = 1/error^2 )
summary(mod2)
#Problem 2
data(gammaray)
mod2 = lm(flux ~ time, data = gammaray, weights = 1/error^2 )
summary(mod2)
g2 = lm(flux ~ time + I(time^2), weights = sd^-2, gammaray)
round(summary(g2)$coef,dig=3)
g3 = lm(flux ~ time + I(time^2) + I(time^3) , weights = sd^-2, gammaray)
round(summary(g3)$coef,dig=3)
g4 = lm(flux ~ time + I(time^2) + I(time^3) + I(time^4), weights = sd^-2, gammaray)
round(summary(g4)$coef,dig=3)
g2 = lm(flux ~ time + I(time^2), weights = error^-2, gammaray)
round(summary(g2)$coef,dig=3)
g3 = lm(flux ~ time + I(time^2) + I(time^3) , weights = error^-2, gammaray)
round(summary(g3)$coef,dig=3)
g4 = lm(flux ~ time + I(time^2) + I(time^3) + I(time^4), weights = error^-2, gammaray)
round(summary(g4)$coef,dig=3)
#Problem 3
data(longley)
head(longley)
mod3 = lm(Employed~.,data = longley)
e$val
#a
#condition number
m3_mat = model.matrix(mod3)[,-1]
e = eigen(t(m3_mat) %.% m3_mat)
e$val
e = eigen(t(m3_mat) %*% m3_mat)
e$val
e$val
summary(mod3)
e$val
length(longley)
#standardize matrix
m3_mat = model.matrix(mod3)[,-1]
m3_mat = m3_mat - matrix(apply(m3_mat, 2, mean), 7,6, byrow = T)
m3_mat = m3_mat - matrix(apply(m3_mat, 2, mean), 7,6, byrow = T)
longley
length(longley)
rowsum(longley)
count(longley)
View(longley)
m3_mat = m3_mat - matrix(apply(m3_mat, 2, mean), 16,6, byrow = T)
m3_mat = m3_mat / matrix(apply(m3_mat, 2, sd), 16,6, byrow = T)
apply(m3_mat,2,mean)
apply(m3_mat,2,var)
sqrt(e$val[1]/e$val)
#condition number
e = eigen(t(m3_mat) %*% m3_mat)
sqrt(e$val[1]/e$val)
#b
round(vif(m3_mat), dig=2)
#b
#pairwise correlation
round(cor(longley), dig=2)
#c
round(vif(m3_mat), dig=2)
sqrt(vif(m3_mat)$GNP)
sqrt(vif(m3_mat)$[2])
#GNP
sqrt(1788.51)
#Year
sqrt(758.98)
#Population
sqrt(399.15)
#b
#pairwise correlation
round(cor(longley), dig=2)
setwd("/Users/chanm/Desktop/STATclasses/Aaron/STAT426")
CancerR = data.frame(read.csv(file = 'cancer-remission.csv',header = T))
#Problem 2
#add a binary remission column 1=remission 0=no remission
CancerR$Remission = c(rep(0,5),1,1,1,0,1,1,0,1,1)
mod1 = glm(Remission ~ factor(LI),data = CancerR, family = binomial)
summary(mod1)
#a
predict(mod1, data.frame(LI = 8), type = "response")
#a
predict(mod1, data.frame(LI = 8), type = "prob")
#a
predict(mod1, data.frame(LI = 8), type = "response")
mod1 = glm(Remission ~ LI,data = CancerR, family = binomial)
summary(mod1)
deathpenalty <- read.table("deathpenalty.txt")
deathpenalty
dp <- reshape(deathpenalty, v.names="Freq", timevar="DeathPenalty",
idvar=c("Defendant","Victim"), direction="wide")
dp
setwd("/Users/chanm/Desktop/STATclasses/Aaron/STAT426")
CancerR = data.frame(read.csv(file = 'cancer-remission.csv',header = T))
as.table(CancerR)
levels(CancerR$LI)
as.factor(CancerR$LI)
levels(CancerR$LI)
factor(CancerR$LI)
CancerR$LI = as.factor(CancerR$LI)
setwd("/Users/chanm/Desktop/STATclasses/Aaron/STAT426")
CancerR = data.frame(read.csv(file = 'cancer-remission.csv',header = T))
LI = matrix(c(24,35,21,30,1355,603,192,224), nc=2)
View(LI)
View(CancerR)
LI = matrix(c(rep(0,5),1,2,1,0,1,1,0,1,2,2,2,3,3,3,0,1,1,1,0,0,1,0,1), nc=2)
View(LI)
rep(8:36,by=2)
seq(8,36,by=2)
Remis.df = data.frame(LI = gl(14,1, labels = c(seq(8,36,by = 2))),
Remission = gl(2,14,labels = c("Yes","No")),
counts = as.vector(Remis))
Remis = matrix(c(rep(0,5),1,2,1,0,1,1,0,1,2,2,2,3,3,3,0,1,1,1,0,0,1,0,1), nc=2)
Remis.df = data.frame(LI = gl(14,1, labels = c(seq(8,36,by = 2))),
Remission = gl(2,14,labels = c("Yes","No")),
counts = as.vector(Remis))
View(Remis.df)
snoring <- matrix(c(24,35,21,30,1355,603,192,224), nc=2)
snoring.df <- data.frame(snoring=gl(4, 1, labels=c("Never", "Occasional",
"Nearly every night",
"Every night")),
disease=gl(2, 4, labels=c("Yes", "No")),
counts=as.vector(snoring))
View(snoring.df)
Remis.df = Remis.df[rep(seq_len(nrow(Remis.df)),Remis.df$counts),1:2]
View(Remis.df)
snoring.df <- snoring.df[rep(seq_len(nrow(snoring.df)), snoring.df$counts), 1:2]
View(snoring.df)
View(snoring)
View(snoring.df)
View(Remis.df)
levels(snoring.df$snoring) <- c(0, 2, 4, 5)
y <- abs(as.numeric(snoring.df$disease)-2)
x <- as.numeric(as.character(snoring.df$snoring))
fit.glm1 <- glm(y ~ x, family=binomial)
summary(fit.glm1)
fit.glm2 <- glm(snoring ~ c(0, 2, 4, 5), family=binomial)
summary(fit.glm2)
summary(fit.glm1)
mod.t = glm(y~x,family = binomial)
summary(mod.t)
y = abs(as.numeric(Remis.df$Remission))
x = as.numeric(as.character(Remis.df$LI))
mod.t = glm(y~x,family = binomial)
y = abs(as.numeric(Remis.df$Remission)-2)
x = as.numeric(as.character(Remis.df$LI))
mod.t = glm(y~x,family = binomial)
summary(mod.t)
setwd("/Users/chanm/Desktop/STATclasses/Aaron/STAT426")
CancerR = data.frame(read.csv(file = 'cancer-remission.csv',header = T))
##################################
Remis = matrix(c(rep(0,5),1,2,1,0,1,1,0,1,2,2,2,3,3,3,0,1,1,1,0,0,1,0,1), nc=2)
Remis.df = data.frame(LI = gl(14,1, labels = c(seq(8,36,by = 2))),
Remission = gl(2,14,labels = c("Yes","No")),
counts = as.vector(Remis))
Remis.df = Remis.df[rep(seq_len(nrow(Remis.df)),Remis.df$counts),1:2]
levels(Remis.df$LI) = c(seq(8,36,by = 2))
y = abs(as.numeric(Remis.df$Remission)-2)
y
x = as.numeric(as.character(Remis.df$LI))
mod.t = glm(y~x,family = binomial)
summary(mod.t)
glm(as.table(Remis)~c(seq(8,36,by = 2)), family = binomial)
Remis
View(CancerR)
Remis.df = data.frame(LI = gl(14,1, labels = c(seq(8,36,by = 2))),
Remission = gl(2,14,labels = c("Yes","No")),
counts = as.vector(Remis))
Remis.df
Remis.df = Remis.df[rep(seq_len(nrow(Remis.df)),Remis.df$counts),1:2]
Remis.df
levels(Remis.df$LI) = c(seq(8,36,by = 2))
y = abs(as.numeric(Remis.df$Remission)-2)
x = as.numeric(as.character(Remis.df$LI))
mod.t = glm(y~x,family = binomial)
summary(mod.t)
tab.R = table(x,y, dnn=c('LI','Remission'))
glm(tab.R ~ as.numeric(rownames(tab.R)),family = binomial)
setwd("/Users/chanm/Desktop/STATclasses/Aaron/STAT426")
CancerR = data.frame(read.csv(file = 'cancer-remission.csv',header = T))
#Problem 2
#add a binary remission column 1=remission 0=no remission
CancerR$Remission = c(rep(0,5),1,1,1,0,1,1,0,1,1)
mod1 = glm(Remission ~ LI,data = CancerR, family = binomial)
summary(mod1)
#a
predict(mod1, data.frame(LI = 8), type = "response")
#b
coef(mod2)
-coef(mod2)[1]/coef(mod2)[2]
#################################################
testing = data.frame(lapply(CancerR, rep, CancerR$NC))
mod2 = glm(cbind(NC,NR) ~ LI,data = testing, family = binomial)
summary(mod2)
##################################
Remis = matrix(c(rep(0,5),1,2,1,0,1,1,0,1,2,2,2,3,3,3,0,1,1,1,0,0,1,0,1), nc=2)
Remis.df = data.frame(LI = gl(14,1, labels = c(seq(8,36,by = 2))),
Remission = gl(2,14,labels = c("Yes","No")),
counts = as.vector(Remis))
Remis.df = Remis.df[rep(seq_len(nrow(Remis.df)),Remis.df$counts),1:2]
levels(Remis.df$LI) = c(seq(8,36,by = 2))
y = abs(as.numeric(Remis.df$Remission)-2)
x = as.numeric(as.character(Remis.df$LI))
mod.t = glm(y~x,family = binomial)
summary(mod.t)
y = abs(as.numeric(Remis.df$Remission))
x = as.numeric(as.character(Remis.df$LI))
mod.t = glm(y~x,family = binomial)
predict(mod.t, data.frame(x= 8), type = "response")
coef(mod.t)
-coef(mod.t)[1]/coef(mod.t)[2]
##################################
Remis = matrix(c(rep(0,5),1,2,1,0,1,1,0,1,2,2,2,3,3,3,0,1,1,1,0,0,1,0,1), nc=2)
Remis.df = data.frame(LI = gl(14,1, labels = c(seq(8,36,by = 2))),
Remission = gl(2,14,labels = c("Yes","No")),
counts = as.vector(Remis))
Remis.df = Remis.df[rep(seq_len(nrow(Remis.df)),Remis.df$counts),1:2]
levels(Remis.df$LI) = c(seq(8,36,by = 2))
y = as.numeric(Remis.df$Remission)
x = as.numeric(as.character(Remis.df$LI))
mod.t = glm(y~x,family = binomial)
summary(mod.t)
tab.R = table(x,y, dnn=c('LI','Remission'))
glm(tab.R ~ as.numeric(rownames(tab.R)),family = binomial)
View(testing)
#################################################
testing = data.frame(lapply(CancerR, rep, CancerR$NC))
setwd("/Users/chanm/Desktop/STATclasses/Aaron/STAT426")
CancerR = data.frame(read.csv(file = 'cancer-remission.csv',header = T))
View(CancerR)
#################################################
CancerR$Remission_Y =
CancerR$Remission_N = CancerR$NC - CancerR$NR
View(CancerR)
#################################################
CancerR$Remission_Y = CancerR$NR
CancerR$Remission_N = CancerR$NC - CancerR$NR
mod2 = glm(cbind(Remission_Y,Remission_N) ~ LI,data = testing, family = binomial)
mod2 = glm(cbind(Remission_Y,Remission_N) ~ LI,data = CancerR, family = binomial)
summary(mod2)
#Problem 2
#add a counts for number of Remission and number not in Remission
CancerR$Remission_Y = CancerR$NR
CancerR$Remission_N = CancerR$NC - CancerR$NR
mod1 = glm(Remission ~ LI,data = CancerR, family = binomial)
summary(mod1)
setwd("/Users/chanm/Desktop/STATclasses/Aaron/STAT426")
CancerR = data.frame(read.csv(file = 'cancer-remission.csv',header = T))
#Problem 2
#add a counts for number of Remission and number not in Remission
CancerR$Remission_Y = CancerR$NR
CancerR$Remission_N = CancerR$NC - CancerR$NR
mod1 = glm(Remission ~ LI,data = CancerR, family = binomial)
mod1 = glm(cbind(Remission_Y,Remission_N) ~ LI,data = CancerR, family = binomial)
summary(mod1)
source('C:/Users/chanm/Desktop/STATclasses/Aaron/STAT426/STAT426 HW4.R')
